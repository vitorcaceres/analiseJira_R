---
title: "Analise Atividades de desenvolvimento"
author: "Vítor Cáceres E Daniel Barnasque"
date: "11/12/2020"
output: pdf_document
---

Para essa atividade, nosso objetivo é analisar uma base de dados de 3 anos de atividades de desenvolvimento de software. Todos os nomes de desenvolvedores e projetos são fictícios. 



```{r warnings = FALSE, message = FALSE}
rm(list=ls())
library(dplyr)
library(lubridate)
library(tidyverse)

my.dir <- getwd()
setwd(my.dir)

my.database <- read_csv2("database_Jira.csv")
summary(my.database)

```


Após configurações iniciais, carregamos o CSV extraido da plataforma de gerenciamento de atividades Jira usando o read_csv2 e operamos algumas funções para limpeza dos dados.

Outra operação importante foi a criação da coluna performance, que calculará a cada tarefa a performance do desenvoldor, de modo que abaixo de 1 sejam atividades feitas abaixo da estimativa inicial, 1 para atividades feitas exatamente no tempo estimado e acima de 1 as atividades com atraso.


```{r}
my.database$Performance <- my.database$'Tempo Gasto'/my.database$Estimativa
my.database <- na.omit(my.database)
my.database <- filter(my.database, !grepl('N/D', Responsável))


summary(my.database$Performance)
```

Através de uma análise de distribuição, identificamos muitos ouliers na performance o que prejudicaria algumas analises, por isso os retiramos através da função boxplot.


```{r}
my.databaseSemOutlier <- my.database
outliers <- boxplot(my.databaseSemOutlier$Performance, plot = FALSE)$out
my.databaseSemOutlier <- my.databaseSemOutlier[-which(my.databaseSemOutlier$Performance %in% outliers),]

boxplot(my.database$Performance)
boxplot(my.databaseSemOutlier$Performance)
```


Agora começando a focar mais nas análises, calculamos a média da performance histórica dos desenvolvedores.


```{r message = FALSE}
my.databasePerf <- group_by(my.databaseSemOutlier, Responsável) %>%
                            summarize(Performance=mean(Performance)) %>%
                            arrange(Performance)

head(my.databasePerf)
```


Após a medição da performance, pensamos em fazer algumas análises sazonais. Para isso, primeiro tivemos que tratar a coluna que mostra a ultima alteração de status da task. Após transforma-la em data, criamos colunas para ano, mês e dias.

```{r}
my.databaseSemOutlier$`Registro de Trabalho.updated` <- substr(my.databaseSemOutlier $`Registro de Trabalho.updated`,0,11)
my.databaseSemOutlier$`Registro de Trabalho.updated` <- parse_date_time(my.databaseSemOutlier$`Registro de Trabalho.updated`, orders = c("ymd", "dmy", "mdy"))

my.databaseSemOutlier$Ano <- year(my.databaseSemOutlier$`Registro de Trabalho.updated`)
my.databaseSemOutlier$Mes <- month(my.databaseSemOutlier$`Registro de Trabalho.updated`)
my.databaseSemOutlier$DiaSemana <- weekdays(my.databaseSemOutlier$`Registro de Trabalho.updated`)

my.demonstraçãosazonal <- my.databaseSemOutlier %>% select(`Tipo de item`, `Ano`, `Mes`, `DiaSemana`)

print(my.demonstraçãosazonal)
```

Agora sim podemos tirar a dúvida dos meses e dias da semana em que os desenvolvedores melhor trabalham.

```{r message = FALSE}
my.averageResultsPerMonth <- group_by(my.databaseSemOutlier, Mes) %>%
                              summarize(Performance=mean(Performance))

plot(my.averageResultsPerMonth, type="h")

my.PerformanceDiaSemana <- my.databaseSemOutlier %>% filter(Ano == "2020")
                                                      
my.PerformanceDiaSemana <- my.databaseSemOutlier %>% group_by(DiaSemana) %>%
                                                      summarize(Média=mean(Performance)) %>%
                                                      arrange(Média)
print(my.PerformanceDiaSemana)

```

Agora podemos ver também quem sao os desnevolvedores que melhor performaram em 2020:

```{r message = FALSE}
my.devranking2020 <- my.databaseSemOutlier %>% filter(Ano == "2020") %>%
                                              group_by(Responsável) %>%
                                              summarize(MinhaMedia=mean(Performance)) %>%
                                              arrange(`MinhaMedia`)

head(my.devranking2020)
```

Após isso, criamos uma proposta de senioridade com base na distribuição das performances dos desenvolvedores em 2020. Fazemos isso utilizando o conceito de quartis e a função boxplot.

```{r}
my.1stQuartil <- quantile(my.databaseSemOutlier$Performance, 0.25)
my.2ndQuartil <- quantile(my.databaseSemOutlier$Performance, 0.50)
my.3thQuartil <- quantile(my.databaseSemOutlier$Performance, 0.75)

my.devranking2020$Senioridade <- ifelse(my.devranking2020$`MinhaMedia` < my.1stQuartil, "Senior", 
                                        ifelse(my.devranking2020$`MinhaMedia` < my.2ndQuartil, "Middle",
                                               ifelse(my.devranking2020$`MinhaMedia` < my.3thQuartil, "Junior", "Intern")))

head(my.devranking2020)
```


















